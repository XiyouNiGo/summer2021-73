# 开发日志

## 第二周

+ rebase删除了原有commit。

+ 项目结构：

  ![image-20210715164456638](C:\Users\NiGo\AppData\Roaming\Typora\typora-user-images\image-20210715164456638.png)

  ![image-20210715164517569](C:\Users\NiGo\AppData\Roaming\Typora\typora-user-images\image-20210715164517569.png)

+ iSulad如何对接K8S：

  ![image-20210715164653478](C:\Users\NiGo\AppData\Roaming\Typora\typora-user-images\image-20210715164653478.png)

+ RootFS到底是啥：

  ![image-20210715212814216](C:\Users\NiGo\AppData\Roaming\Typora\typora-user-images\image-20210715212814216.png)

+ ! [rejected]   master -> master (non-fast-forward)

+ images指定特定镜像名应该怎么实现

+ 减少圈复杂度

+ isulad不支持多重参数，例如：docker images --filter=reference='busy*:uclibc' --filter=reference='busy*:glibc'

# 第三周

+ images指定特定镜像名通过将指定的镜像名转化成--filter=reference='image_name:*'合理吗

+ client中对request采用栈内存，对respond却采用动态内存，原因是什么？是否可以修改来提高项目性能。

+ 关于一些代码缩写不太懂，比如shim（好像是容器里的东西）、rest（是restful风格吗）、client回调函数中的ops、cc（错误码？）、bim、mock

+ 函数util_check_inherited_exclude_fds的作用？

+ 为什么docker需要cache id？

+ SizeRw int64 The size of files that have been created or changed by this container.

+ SizeRootFs int64 The total size of all the files in this container.

+ https://docs.docker.com/engine/api/v1.25/#operation/ContainerList

+ GetContainerLayerSize流程：

  + 根据container-id获取读写层（containers_store_get）（可读写层的cache-id就是container-id）

  + 从读写层计算SizeRw大小(diff_size)

    ```
    // Size represents the size of the writable layer
    // as calculated by the total size of the files
    // changed in the mutable layer.
    ```

  + 获取该读写层的父层（image_top_layer）

    ```
    // Parent returns the layer which the writable
    // layer was created from.
    ```

  + SizeRootFs：父层大小 + SizeRw

    ```
    // Size returns the size of the entire layer chain. The size
    // is calculated from the total size of all files in the layers.
    ```

  + ```
    // DiffSize calculates the changes between the specified id
    // and its parent and returns the size in bytes of the changes
    // relative to its base filesystem directory.
    ```

+ 结构体：container_t、storage_rootfs、db_image

+ g_graphdriver全局driver配置。

+ 函数：rootfs_store_get_rootfs、db_read_image

+ storage_img_get_summary：镜像名 -> image_summary

+ lookup：id -> 各种结构体

+ get_image_layers：top_layer -> 一条diff_id串起来的struct linked_list

+ layer_store_lookup：diff_id -> struct layer

+ lookup_with_lock：diff_id -> layer_t

+ container_get_image：container_t -> image_name

+ image_id直接到container_t获取

+ **请参考do_storage_check_image**。

+ 文件：src/daemon/modules/image/oci/storage/rootfs_store/rootfs_store.c

+ layerid（digest）、chainid、imageid、diffid具体含义。

  + layerID -> diffID -> chainID -> cacheID
  + containerID = mountID

+ roLayer:/var/lib/docker/image/overlay2/layerdb/sha256

+ mountLayer:/var/lib/docker/image/overlay2/layerdb/mount

+ chainid：/var/lib/docker/image/overlay2/layerdb/sha256/

+ layerID和diffID的对应关系在diffid-by-digest和v2metadata-by-diffid

+ RootFs中的是diffID

+ cacheID主要存在于/var/lib/docker/overlay2/<cache-id>

+ Image ID是在本地由Docker根据镜像的描述文件计算的，并用于imagedb的目录名称

+ 为什么docker相关功能放在image目录，我写的应该放在哪里？

+ *// note: we use container id as the layer id of the container*

+ volume这是自己做了一套参数解析吗，会不会不太统一。

+ isula images和inspect看到的size大小不一样（size更大）

+ oci、ext、embeded有什么区别？（只知道oci是个容器标准）

+ 难点在于理解逻辑结构和实际的存储结构，逻辑结构和docker应该是一样的，除了docker的读写层用的是cache-id，isula用的是container-id，然后就是物理结构，isula具体如何组织和存放（只看到是sqlite3），最后就是如何在isula的架构下，在正确的层写出合理的代码。

+ isula容器存储物理架构：

  + overlay：对应cacheid，实际存储的位置
  + overlay-containers：对应imageid
  + overlay-images：对应imageid
  + overlay-layers：对应diffid，存放layer的压缩包；读写层parent：父层的chainid
  + containerid = layerid = cacheid (d8)
  + imageid (69) != layerid = cacheid (5b)

+ ls只能统计目录文件的大小（linux下一切皆文件），而不是目录，要想知道目录下所有文件大小，应该使用du。

+ 白盒测试和黑盒测试、gmock（很多宏）。

+ rest接口。

+ CI中[[ $? -ne 0 ]]、2>&1是啥。。。

+ 诸多map_store存放全局的一些信息，由isulad_server_init_common进行初始化和载入工作。

+ 想做一些跟mock有关的工作。

+ 不太习惯isulad的代码风格。。

+ 逻辑：

  + 一是用lookup_with_lock，通过容器id获取结构体layer_t（里面有个diff_size我觉得就是读写层的大小），接着得获取image的信息，从container_get_image函数，container_t（这个结构体用containers_store_get获取） -> image_id；接着就是image_store_get_image，从image id获取到imagetool_image，里面有个top_layer，是顶层的diff_id，最后是一个循环，使用layer_store_lookup，从这个diff_id获取struct layer（里面有parent，这是父层的diff_id，以及uncompress_size，这个应该就是层的大小，我在copy_json_to_layer中看到的），加起来应该就是

+ isulad的注释太少了，相比之下docker就多了很多，这也比较方便其他有志之士参与贡献。

+ docker里啥是naiveDiff啊，不是直接调用工具类计算大小就行了吗。

+ overlay和aufs区别（在docker源码中看到AUFS doesn't need the parent layer to calculate the diff size.）

+ Not using native diff for overlay2, this may cause degraded performance for building images。

+ 在阅读源码的过程中，看到很普遍的使用malloc/free，即使多处只是在函数开始申请固定空间，函数结束释放。我认为只有两种理由需要使用动态内存，一是需要的空间不确定，二是需要传参到别的函数。很多场景我觉得使用栈内存即可，效率更高。不使用它的理由可能是堆区比栈区更大。

+ device mapper diffsize应该如何实现。

+ 如果Overlayfs的某一个目录是单纯来自lower layer或是lower layer和upper layer合并的，那默认情况下，用户无法对该目录执行rename系统调用，否则会返回-EXDEV错误。不过你会发现通过mv命令重命名该目录依然可以成功，那是因为mv命令的实现对rename系统调用的-EXDEV错误进行规避（先拷贝，再删除，不保证原子性）。

+ 打开redirect  dir之后，将支持单纯来自lower层和合并目录的rename系统调用。由于目录里可能会包含很多子目录或文件，overlayfs需要保证rename系统调用的原子性，因此它不能像mv命令那样将目录里的各个子目录和文件都挨个copyup到upper层中，所以overlayfs设计了一种redirect  xattr扩展属性，其内容是lower层原始目录的相对路径（相对lower层挂载根目录或当前rename目录的父目录），设置在upper层中的目标目录上，并不会copyup原始目录中的子目录或文件。用户通过merge目录扫描目录项时，overlayfs在扫描upper层目录时会检查它的redirect xattr扩展属性并找到原始lower层目录，同时将原始目录下的目录项也返回给用户。

+ whiteout文件是否需要计算？（即使计算，经实验也是0）

+ isula没有init层，SizeRw和SizeRootFs逻辑和docker是否不一致？

+ 用户通过merge目录扫描目录项时，overlayfs在扫描upper层目录时会检查它的redirect xattr扩展属性并找到原始lower层目录，同时将原始目录下的目录项也返回给用户。

+ 支持了info中的Runtimes、Default Runtime、Insecure Registries、Registry Mirrors（grpc使用repeated字段）。

+ g_isulad_conf保存daemon的各种配置。

+ test/image/oci/oci_ut_common.h不知道怎么改。

+ Go中有Once，如何在c中复刻。(我使用pthread_once_t)

+ docker源码中的doesSupportNativeDiff为何要判断RunningInUserNS。

+ Go ioutil中tempDir如何在c中复刻。

+ native overlay diff和naive overlay diff的区别。

+ isulad是怎么通过cmake组织起来的。

+ linux mount系统调用对于overlay应该怎么使用。

+ opaque flag erroneously copied up, consider update to kernel 4.8 or later to fix

+ 增加了对overlay的支持。

## docker对应源码的验证

ContainerInspect -> ContainerInspectCurrent -> GetContainerLayerSize
roLayer、mountedLayer共同实现Layer接口，roLayer的DiffSize返回预先读入的常量size，Size递归调用父层的Size，而mountedLayer的DiffSize直接调用对应驱动的DiffDriver计算。

## 容器创建之daemon

container_create_cb -> do_image_create_container_roofs_layer -> im_prepare_container_rootfs -> oci_prepare_rf -> storage_rootfs_create

