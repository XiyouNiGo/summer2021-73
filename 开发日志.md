# 开发日志

## 第二周

+ rebase删除了原有commit。

+ 项目结构：

  ![image-20210715164456638](C:\Users\NiGo\AppData\Roaming\Typora\typora-user-images\image-20210715164456638.png)

  ![image-20210715164517569](C:\Users\NiGo\AppData\Roaming\Typora\typora-user-images\image-20210715164517569.png)

+ iSulad如何对接K8S：

  ![image-20210715164653478](C:\Users\NiGo\AppData\Roaming\Typora\typora-user-images\image-20210715164653478.png)

+ RootFS到底是啥：

  ![image-20210715212814216](C:\Users\NiGo\AppData\Roaming\Typora\typora-user-images\image-20210715212814216.png)

+ ! [rejected]   master -> master (non-fast-forward)

+ images指定特定镜像名应该怎么实现

+ 减少圈复杂度

+ isulad不支持多重参数，例如：docker images --filter=reference='busy*:uclibc' --filter=reference='busy*:glibc'

# 第三周

+ images指定特定镜像名通过将指定的镜像名转化成--filter=reference='image_name:*'合理吗

+ client中对request采用栈内存，对respond却采用动态内存，原因是什么？是否可以修改来提高项目性能。

+ 关于一些代码缩写不太懂，比如shim（好像是容器里的东西）、rest（是restful风格吗）、client回调函数中的ops、cc（错误码？）、bim、mock

+ 函数util_check_inherited_exclude_fds的作用？

+ 为什么docker需要cache id？

+ SizeRw int64 The size of files that have been created or changed by this container.

+ SizeRootFs int64 The total size of all the files in this container.

+ https://docs.docker.com/engine/api/v1.25/#operation/ContainerList

+ GetContainerLayerSize流程：

  + 根据container-id获取读写层（containers_store_get）（可读写层的cache-id就是container-id）

  + 从读写层计算SizeRw大小(diff_size)

    ```
    // Size represents the size of the writable layer
    // as calculated by the total size of the files
    // changed in the mutable layer.
    ```

  + 获取该读写层的父层（image_top_layer）

    ```
    // Parent returns the layer which the writable
    // layer was created from.
    ```

  + SizeRootFs：父层大小 + SizeRw

    ```
    // Size returns the size of the entire layer chain. The size
    // is calculated from the total size of all files in the layers.
    ```

  + ```
    // DiffSize calculates the changes between the specified id
    // and its parent and returns the size in bytes of the changes
    // relative to its base filesystem directory.
    ```

+ 结构体：container_t、storage_rootfs、db_image

+ 函数：rootfs_store_get_rootfs、db_read_image

+ storage_img_get_summary：镜像名 -> image_summary

+ lookup：id -> 各种结构体

+ get_image_layers：top_layer -> 一条diff_id串起来的struct linked_list

+ layer_store_lookup：diff_id -> struct layer

+ lookup_with_lock：diff_id -> layer_t

+ container_get_image：container_t -> image_id

+ **请参考do_storage_check_image**。

+ 文件：src/daemon/modules/image/oci/storage/rootfs_store/rootfs_store.c

+ layerid（digest）、chainid、imageid、diffid具体含义。

  + layerID -> diffID -> chainID -> cacheID
  + containerID = mountID

+ roLayer:/var/lib/docker/image/overlay2/layerdb/sha256

+ mountLayer:/var/lib/docker/image/overlay2/layerdb/mount
+ chainid：/var/lib/docker/image/overlay2/layerdb/sha256/
+ layerID和diffID的对应关系在diffid-by-digest和v2metadata-by-diffid
+ RootFs中的是diffID
+ cacheID主要存在于/var/lib/docker/overlay2/<cache-id>
+ Image ID是在本地由Docker根据镜像的描述文件计算的，并用于imagedb的目录名称
+ 为什么docker相关功能放在image目录，我写的应该放在哪里？
+  *// note: we use container id as the layer id of the container*
+ volume这是自己做了一套参数解析吗，会不会不太统一。
+ isula images和inspect看到的size大小不一样（size更大）
+ oci、ext、embeded有什么区别？（只知道oci是个容器标准）
+ 难点在于理解逻辑结构和实际的存储结构，逻辑结构和docker应该是一样的，除了docker的读写层用的是cache-id，isula用的是container-id，然后就是物理结构，isula具体如何组织和存放（只看到是sqlite3），最后就是如何在isula的架构下，在正确的层写出合理的代码。
+ isula容器存储物理架构：
  + overlay：对应cacheid，实际存储的位置
  + overlay-containers：对应imageid
  + overlay-images：对应imageid
  + overlay-layers：对应diffid，存放layer的压缩包；读写层parent：父层的chainid
  + containerid = layerid = cacheid (d8)
  + imageid (69) != layerid = cacheid (5b)
+ ls只能统计目录文件的大小（linux下一切皆文件），而不是目录，要想知道目录下所有文件大小，应该使用du。
+ 白盒测试和黑盒测试、gmock（很多宏）。
+ rest接口。
+ CI中[[ $? -ne 0 ]]、2>&1是啥。。。
+ 诸多map_store存放全局的一些信息，由isulad_server_init_common进行初始化和载入工作。
+ 想做一些跟mock有关的工作。
+ 不太习惯isulad的代码风格。。
+ 逻辑：
  + 一是用lookup_with_lock，通过容器id获取结构体layer_t（里面有个diff_size我觉得就是读写层的大小），接着得获取image的信息，从container_get_image函数，container_t（这个结构体用containers_store_get获取） -> image_id；接着就是image_store_get_image，从image id获取到imagetool_image，里面有个top_layer，是顶层的diff_id，最后是一个循环，使用layer_store_lookup，从这个diff_id获取struct layer（里面有parent，这是父层的diff_id，以及uncompress_size，这个应该就是层的大小，我在copy_json_to_layer中看到的），加起来应该就是
+ isulad的注释太少了，相比之下docker就多了很多，这也比较方便其他有志之士参与贡献。
+ docker里啥是naiveDiff啊，不是直接调用工具类计算大小就行了吗。
+ overlay和aufs区别（在docker源码中看到AUFS doesn't need the parent layer to calculate the diff size.）
+ Not using native diff for overlay2, this may cause degraded performance for building images。

## docker对应源码的验证

ContainerInspect -> ContainerInspectCurrent -> GetContainerLayerSize
roLayer、mountedLayer共同实现Layer接口，roLayer的DiffSize返回预先读入的常量size，Size递归调用父层的Size，而mountedLayer的DiffSize直接调用对应驱动的DiffDriver计算。

## 容器创建之daemon

container_create_cb -> do_image_create_container_roofs_layer -> im_prepare_container_rootfs -> oci_prepare_rf -> storage_rootfs_create

